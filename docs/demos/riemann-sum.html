<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Riemann Sums</title>
  <link rel="stylesheet" href="main.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    function clickInfo() {
      var el = document.querySelector('#infop'); 
      var elParent = document.querySelector('#infobutton'); 
      if (el.style.display == 'block') { 
        console.log('Block found'); 
        elParent.innerHTML = "<b>&oplus; Info</b>" ;
        // el.style.display = 'none';
        el.style.display = 'none';
        elParent.style.height = '1em';
      } else {
        el.style.display = 'block';
        // el.style.visibility = 'visible';
        elParent.innerHTML = "<b>&otimes; Info</b>" ;
        elParent.style.height = 'fit-content';
      } 
    }
  </script>
</head>
<body>


      <canvas id="c"></canvas>
      
<div id="infocontainer" style="width: 800px;">

  <div id="info"> <span class="noselect" id="infobutton" onclick="javascript:clickInfo();"><b>&oplus; Info</b></span>
    <p id="infop" style="display: none; width: 800px;">Visualize a Riemann Sum of a double integral. If I keep typing, how wide does this get ;Lorem ipsum dolor, sit amet consectetur adipisicing elit. Est vero error culpa sed, animi quaerat! Illum, vitae debitis eos ut ipsum qui, error eum saepe ratione nesciunt repellat iusto quis!</p>
  </div>
</div>

</body>
<script type="module">

/* jshint esversion: 6 */

import * as THREE from 'https://unpkg.com/three@0.121.0/build/three.module.js';
import {OrbitControls} from 'https://unpkg.com/three@0.121.0/examples/jsm/controls/OrbitControls.js';
import {GUI} from './dat.gui.module.js';

/* Some constants */
const nX = 30; // resolution for surfaces
const xmin = -2; // domain of function
const xmax = 4;
const ymin = -1;
const ymax = 3;
const gridMax = Math.max(...[xmin,xmax,ymin,ymax].map(Math.abs));
const gridStep = 1;
// console.log("gridMax = ",gridMax,[xmin,xmax,ymin,ymax].map(Math.abs));

var scene = new THREE.Scene();
var canvas = document.querySelector("#c");
// var canvas = document.getElementById("canvas-plot-1");

scene.background = new THREE.Color( 0xdddde8 );

var camera = new THREE.PerspectiveCamera(75, canvas.clientWidth/canvas.clientHeight, 0.1, 1000);

camera.position.z = 1.2*(xmax - xmin) + xmax;
camera.position.y = 1 ;
camera.position.x = ymin - .2*(ymax - ymin);
camera.lookAt( 0,0,0 );


var renderer = new THREE.WebGLRenderer({antialias: true, alpha : true,canvas: canvas});
// renderer.setClearColor("#e5e5f5");

const gui = new GUI();

canvas.width  = canvas.clientWidth;
canvas.height = canvas.clientHeight;
renderer.setViewport(0, 0, canvas.clientWidth, canvas.clientHeight);
renderer.setSize(window.innerWidth, window.innerHeight);
camera.aspect = window.innerWidth / window.innerHeight;

window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    console.log(canvas.width,canvas.clientWidth)
    camera.updateProjectionMatrix();
    render();
});

var ii = new THREE.Vector3( 0, 0, 1 );
var jj = new THREE.Vector3( 1, 0, 0 );
var kk = new THREE.Vector3( 0, 1, 0 );

//normalize the direction vector (convert to vector of length 1)

var origin = new THREE.Vector3( 0, 0, 0 );
var length = gridMax + .05 * gridMax;
var hex = 0x330033;
var axesArray = [ii,jj,kk];
var arrayLength = axesArray.length;
for (var i = 0; i < arrayLength; i++) {
    var dir = axesArray[i];
    // dir.normalize(); // not needed for standard basis
    var arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex , .02*gridMax);
    scene.add( arrowHelper );
    // gui.add(arrowHelper,'visible').name("Axis ${i}");
}
var lineMaterial = new THREE.LineBasicMaterial( { color: 0x000000, transparent: true, opacity: 0.8 } );

for (let j = -(10*gridMax); j <= (10*gridMax); j += gridStep) {
  var points = [];
  points.push( new THREE.Vector3( j, 0, -(10*gridMax) ) );
  points.push( new THREE.Vector3( j, 0, (10*gridMax) ) );

  var geometry = new THREE.BufferGeometry().setFromPoints( points );
  scene.add(new THREE.Line(geometry,lineMaterial));
   
  points = [];
  points.push( new THREE.Vector3( -(10*gridMax), 0, j ) );
  points.push( new THREE.Vector3( (10*gridMax), 0, j ) );

  geometry = new THREE.BufferGeometry().setFromPoints( points );
  scene.add(new THREE.Line(geometry,lineMaterial));

 }

// Axes
var axesHolder = new THREE.Object3D();
scene.add(axesHolder);
var axesMaterial = new THREE.MeshBasicMaterial( {color: 0x320032} );
for (let index = 0; index < axesArray.length; index++) {
  const ax = axesArray[index];
  var geometry = new THREE.CylinderGeometry( gridStep/16, gridStep/16, gridMax*3, 12 );
  var coneGeometry = new THREE.ConeGeometry( gridStep/10, gridStep/3, 12 );
  var cylinder = new THREE.Mesh( geometry, axesMaterial );
  // cylinder.position.y = gridMax*1.1/2;
  var cone = new THREE.Mesh(coneGeometry,axesMaterial);
  if (ax == ii) {
    cylinder.rotation.x = Math.PI/2;
  } else { if (ax == jj) {
    cylinder.rotation.z = -Math.PI/2;
  }}
  cone.position.y = gridMax*3/2 + gridStep/6;
  cylinder.add(cone);
  axesHolder.add( cylinder );
}

// Fonts
var axesText = [];
var loader = new THREE.FontLoader();
var font = loader.load(
	// resource URL
	'fonts/P052_Italic.json',
  function (font) {
    // var shapes = font.generateShapes( 'x', 100 );
    // var textGeo = new THREE.BufferGeometry(shapes);
    var textGeo = new THREE.TextGeometry( 'x', {
		font: font,
		size: 0.5,
		height: 0,
		curveSegments: 12,
		bevelEnabled: false
	} );
    // var textMaterial = new THREE.MeshBasicMaterial({color: axesMaterial})
    var text = new THREE.Mesh(textGeo,axesMaterial);
    // text.computeBoundingBox();
    text.rotation.y =  - Math.PI/2;
    text.position.z = gridMax*1.6;
    scene.add(text);
    axesText.push(text);
    console.log("pushed: ",axesText)
  },
  // onProgress callback
	function ( xhr ) {
		console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
	},

	// onError callback
	function ( err ) {
		console.log( 'An error happened' );
	}
);



// var axesHelper = new THREE.AxesHelper( b );
// scene.add( axesHelper );

const a = -2;
const b = 4;
const c = -1;
const d = 3;


// Functions

var functionData = {
  f: function(u,v) {
       return 1 - Math.pow(u,2)/4 + Math.pow(v,3)/10
     },
  wave: function(u,v) {
       return (1 - Math.cos(Math.PI*u/2)/2) / (1 + v*v/2);
     }
};

console.log(Object.keys(functionData));

var data = {f: "wave",
            ySlice: 0};

var graphHolder = new THREE.Object3D();
scene.add(graphHolder);
var graphMaterial = new THREE.MeshPhongMaterial({color: 0x555562,shininess: 80, side: THREE.DoubleSide, transparent: true, opacity: 1});
var materialBack = new THREE.MeshLambertMaterial({color: 0xFFF717, side: THREE.DoubleSide, transparent: true, opacity: 1});
var graph = new THREE.Mesh(new THREE.Geometry(),graphMaterial);
graphHolder.add(graph);
var wireframe = new THREE.WireframeGeometry( graph.geometry );
var line = new THREE.LineSegments( wireframe, lineMaterial);
// line.material.depthTest = false;
// line.material.opacity = 0.25;
// line.material.transparent = false;
// line.material.color = '000000';
graphHolder.add(line);

function updateGraph(val) {
  graph.geometry.dispose();
  var volGeometry = new THREE.ParametricGeometry(function(u,v,vec) {  
      u = (1-u)*a + u*b;
      v = (1-v)*c + v*d;
      vec.set(v,functionData[data.f](u,v) ,u);
  }, nX, nX);
  graph.geometry = volGeometry;
  line.geometry.dispose();
  line.geometry = new THREE.WireframeGeometry( graph.geometry );
  // var volSkel = new THREE.LineSegments(volGeometry, lineMaterial);
  // volMesh.add(volSkel);
  render();
}

// updateGraph("f");

var graphFolder = gui.addFolder("Graph");
graphFolder.add(data,'f',Object.keys(functionData)).onChange((val) => {
  updateBoxData(); updateGraph(val); updateSlice(data.ySlice);
  });
graphFolder.add(graph,'visible').name("Show Graph").onChange(updateGraph);
graphFolder.add(graph.material,'opacity',0.0,1.0).onChange(()=>{
  setTimeout(render,100);
});

// Lights

var light = new THREE.PointLight(0xFFFFFF, 1, 1000);
light.position.set(60,50,40);
scene.add(light);

var light2 = new THREE.AmbientLight( 0x404040 ); // soft white light
scene.add( light2 );

var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
scene.add( light );

var controls = new OrbitControls (camera, renderer.domElement);
controls.autoRotate = false;
controls.target.set( ymin/2 + ymax/2,0,xmin/2 + xmax/2 );


// Make the box. 

var boxData = {N: 4, M: 4};
var boxHolder = new THREE.Object3D();
scene.add(boxHolder);
boxHolder.visible = false;

var boxFolder = gui.addFolder("Reimann Sum")
boxFolder.add(boxHolder,'visible').name("Show boxes").onChange(updateBoxData);
boxFolder.add(boxData,'N',1,40,1).onChange(updateBoxData);
boxFolder.add(boxData,'M',1,40,1).onChange(updateBoxData);

// Update box

var boxes = [];
var boxMaterials = []
var boxColors = [0x8383FF,0xFF8383];
for (let c = 0; c < boxColors.length; c++) {
  const color = boxColors[c];
  boxMaterials.push(new THREE.MeshPhongMaterial({color: color,shininess: 80, transparent: true, opacity: 1, side: THREE.DoubleSide}));
}
var boxEdgeMaterial = new THREE.LineBasicMaterial( { color: 0xffffff , linewidth: 2} );

function updateBoxData() {
  // console.log(data,data.f);
  var dx = (xmax - xmin)/boxData.N;
  var dy = (ymax - ymin)/boxData.M;
  var boxGeometry;
  console.log(boxData.N,dx,boxData.M,dy)

  var box;
  var x,y,z;
  for (var j = 0; j < boxes.length; j++) {
    let element = boxes[j];
    boxHolder.remove(element);
  }
  for (var i = 0; i < boxData.N; i++) {
    for (let j = 0; j < boxData.M; j++) {
      x = xmin + i*dx;
      y = ymin + j*dy;
      z = functionData[data.f](x+dx/2,y+dy/2);
      boxGeometry = new THREE.BoxGeometry(dy,Math.abs(z),dx);
      box = new THREE.Mesh(boxGeometry,boxMaterials[(z < 0) ? 1 : 0]);
      box.position.z = x + dx/2;
      box.position.x = y + dy/2;
      box.position.y = z /2;
      boxes.push(box);
      boxHolder.add(box);
      var geometry = new THREE.EdgesGeometry( box.geometry );
      var wireframe = new THREE.LineSegments( geometry, boxEdgeMaterial );
      box.add(wireframe);
  // console.log("Box pos", box.position);
    }
  }
  render();
}

//surface area

// var data = {
//   level: (boxData.x * boxData.y) + 64000/boxData.y + 64000/boxData.x
// };

// var data = {
//   levelInternal: (boxData.x * boxData.y) + 64000/boxData.y + 64000/boxData.x,
//   levelListener: function(val) {
//     var element = document.querySelector("#salevel");
//     element.innerHTML = "$$ SA = xy + 2xz + 2yz = " + val.toFixed() + "\\text{cm}^2 $$";
//     MathJax.typeset();
//   },
//   get level() {
//     return this.levelInternal;
//   },
//   set level(val) {
//     this.levelInternal = val;
//     this.levelListener(val);
//   }
// };

// Slice 
var sliceHolder = new THREE.Object3D();
scene.add(sliceHolder);

function updateSlice(ySlice) {
  for (let index = 0; index < sliceHolder.children.length; index++) {
    const element = sliceHolder.children[index];
    sliceHolder.remove(element);
  }
  var sliceVertices = [];
  var dx = (xmax - xmin)/(nX);
  var f = functionData[data.f];
  var yOld,yNew;
  // sliceVertices.push(new THREE.Vector2(0,0));
  // sliceVertices.push(new THREE.Vector2(xmin,0));
  // for (let index = 0; index <= (nX); index++) {
  //   sliceVertices.push(new THREE.Vector2(xmin + index*dx,functionData[data.f](xmin + index*dx,ySlice)));
  // }
  // sliceVertices.push(new THREE.Vector2(xmax,0));
  // sliceVertices.push(new THREE.Vector2(xmax,0));

  // console.log(sliceVertices);

  // var sliceShape = new THREE.Shape(sliceVertices);
  var sliceShape = new THREE.Shape();
  sliceShape.moveTo(xmin,0);
  // less than 0
  var sliceMinus = new THREE.Shape();
  sliceMinus.moveTo(xmin,0);
  yOld = 0;
  for (let i = 0; i <= (nX); i++) {
    yNew = f(xmin + i*dx,ySlice);
    // interpolate 0-location when changing signs
    if (yNew * yOld < 0) {
      sliceShape.lineTo(xmin + (i-1)*dx + yOld/(yOld - yNew)*dx,0);
      sliceMinus.lineTo(xmin + (i-1)*dx + yOld/(yOld - yNew)*dx,0);
    } 
    
    (yNew >= 0) ? sliceShape.lineTo(xmin + i*dx,yNew) : sliceMinus.lineTo(xmin + i*dx,yNew);
    
    yOld = yNew;
  }

  sliceShape.lineTo(xmax,0);
  sliceShape.lineTo(xmin,0);
  sliceMinus.lineTo(xmax,0);
  sliceMinus.lineTo(xmin,0);


  for (var i = 0; i<=1; i++) {
    var shape = [sliceShape,sliceMinus][i]
    var sliceGeometry = new THREE.ShapeGeometry(shape);
    var slice = new THREE.Mesh(sliceGeometry,boxMaterials[i]);
    slice.position.x = ySlice;
    slice.rotation.y = -Math.PI/2;
    sliceHolder.add(slice);
  }
  render();
}

var sliceFolder = gui.addFolder("Slice");
sliceFolder.add(data,'ySlice',ymin,ymax).name("y-slice").onChange(updateSlice);



var render = function() {
    // controls.update();
    for (let index = 0; index < axesText.length; index++) {
      const element = axesText[index];
      element.lookAt(camera.position);
    }

    renderer.render(scene, camera);
    // requestAnimationFrame(render);
};

render();
controls.addEventListener('change',render);
updateGraph("f");
updateBoxData();
updateSlice(data.ySlice);

// requestAnimationFrame(render);

</script>
</html>